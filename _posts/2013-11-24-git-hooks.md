---
layout: post
title:  "Git Hooks"
date:   2013-11-24 12:48:00
categories: git
---

[Git hooks](http://git-scm.com/book/en/Customizing-Git-Git-Hooks) allow scripts
to be executed based on events that happen (i.e. pushed changes) to the
version control system. The ability to run hooks are not unique to any one
source control system, so the ideas presented here are fortunately portable.

There are client-side hooks and server-side hooks. Client-side hooks are local
hooks; server-side hooks make more sense in the context of
[continuous integration](http://en.wikipedia.org/wiki/Continuous_integration).
I've only really worked with client-side hooks since I tend to not have
elaborate server-side setups.

There is one disadvantage to using hooks: they're not automatic. Users need to
manually enable hooks; they're not cloned with the repository. This makes tons
of sense in terms of security, but is a caveat worth mentioning.

### When to use hooks

There's obviously no silver bullet on when to use hooks. The times I've used
hooks have been when I want to minimize "useless" commits, i.e. commits where
I just fix a typo somewhere or remove an unused import. The following are some
interesting examples that may or may not be worth pursuing, depending on
particular needs:

A hook that:

* Rejects a commit that has trailing whitespace.
* Rejects a commit that causes a compile error.
* Rejects a commit if it causes any of the tests to fail.
* Rejects a commit if its commit message doesn't follow a particular format.
* Rejects a commit if its code doesn't follow a particular style.
* Rejects a commit that has unused imports.

One thing that's fun to do if code is managed by [Jenkins](http://en.wikipedia.org/wiki/Jenkins_\(software\))
is to set up the
[triggering of a new build every time a change is pushed to Github](https://wiki.jenkins-ci.org/display/JENKINS/GitHub+Plugin).

As hinted above: if a group of developers is working on different parts of a
system, it's a good idea to establish and enforce a coding style. It would be
hard to follow code if every different file was created with the author's
favorite coding style in mind. In this scenario, using hooks can help remind
(or force) developers to format their code according to this standard.

### Example hooks

These example hooks all use the "pre-commit" git hook. This means that of
these verifications can be skipped by using `git commit --no-verify`. The
great thing about these scripts is that [Git](http://git-scm.com/downloads)
comes with bash, so they're portable. Also, keep in mind that these scripts
are not meant to be exhaustive.

##### Reject a commit that has trailing whitespace in any .java file:

```bash
#!/bin/bash

# Returns 0 if none of the committed files ending in $filetype have trailing
# whitespace.

filetype="java"

# Only look at files that have been added, modified, or renamed.
bad_files=$(git diff --staged --name-only --diff-filter=AMR | \
  grep "*\.$filetype$" | \
  while read file; do
    if egrep ".* +$" "$file" > /dev/null ; then
        echo "{$file} has trailing whitespace"
    fi
  done
)

if [ -z "$bad_files" ] ; then
  exit 0
else
  echo "$bad_files"
  exit 1
fi
```

##### Reject a commit if it causes the tests to fail (with Gradle).

```bash
#!/bin/bash

# Returns 0 if none of the gradle tests fail. It might be worth checking
# the staged files to see if any are code, that way you don't perform
# this "expensive" check for a documentation update.

# Quietly perform tests. On fail, this will print info about failed tests.
./gradlew -q check

# If ./gradlew returned anything other than 0, the tests failed...
if [ $? -ne 0 ] ; then
    echo "Aborting commit due to failed tests."
    exit 1
fi
```

##### Reject a commit that doesn't follow the "team" style guide.

This runs slowly since we format file-by-file and re-launch Eclipse every
time.  The great thing about this kind of formatting is that it doesn't
require anyone to use a particular IDE to enforce the style (though it does
require everyone to have Eclipse installed).

``` bash
#!/bin/bash

success=0

# Path to Eclipse application
eclipse="/Applications/Eclipse.app/Contents/MacOS/eclipse"
# Path to the formatter configuration file
config=`pwd`"/.settings/org.eclipse.jdt.ui.prefs"

# Only look at the added, modified and renamed files
files=$(git diff --staged --name-only --diff-filter=AMR)

# For every staged file, create a temp file and format it, see if it's
# different from what's staged. This way, we don't modify the staged files.
for file in $files; do
    # Extract the extension, make sure it's .java
    filename=$(basename "$file")
    extension="${filename##*.}"
    if [ "$extension" != "java" ] ; then
        continue
    fi

    file_path=`pwd`/$file
    temp_file=`pwd`/$file.temp.java
    cp "$file_path" "$temp_file"

    # Format with Eclipse, ignoring stdout and stderr
    $eclipse -nosplash -application org.eclipse.jdt.core.JavaCodeFormatter -quiet \
        -config "$config" "$temp_file" > /dev/null 2>&1

    difference=$(diff "$file_path" "$temp_file")
    if [ ! -z "$difference" ] ; then
        echo "'$file' is not formatted properly"
        success=1
    fi

    rm $temp_file
done

exit $success
```
